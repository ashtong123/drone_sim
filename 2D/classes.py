import math
   
class Drone_2D:
    def __init__(self, m, I, b, h, k):
        self.m = m
        self.I = I
        self.b = b
        self.h = h
        self. k = k
        
        self.pos = [0.0, 0.0]       #position of CoG (x, y)
        self.vel = [0.0, 0.0]       #velocity vector (x, y)
        self.rot = [0.0]            #angular velocity
        self.omega = [0.0]          #angle to parallel
        self.motor_output = [0.0, 0.0]
    
    #motor output is a list of motor speeds in rpm
    def update(self, dt):
        #forces and torques generated by motor ouputs:
        mo1 = self.motor_output[0]
        mo2 = self.motor_output[1]
        F1 = self.k*(mo1**2)
        F2 = self.k*(mo2**2)
        T = (self.b/2)*(F1 - F2)
        #resultant accelerations
        Fx = F1*math.cos(math.radians(90+self.rot[0])) + F2*math.cos(math.radians(90+self.rot[0]))
        Fy = -self.m*9.81 + F1*math.sin(math.radians(90+self.rot[0])) + F2*math.sin(math.radians(90+self.rot[0]))
        Ax = Fx/self.m
        Ay = Fy/self.m
        Alpha = T/self.I
        #velocity updates
        self.vel[0] += Ax*dt
        self.vel[1] += Ay*dt
        self.omega[0] += Alpha*dt
        #position updates
        self.pos[0] += self.vel[0]*dt + 0.5*Ax*(dt**2)
        self.pos[1] += self.vel[1]*dt + 0.5*Ay*(dt**2)
        self.rot[0] += self.omega[0]*dt + 0.5*Alpha*(dt**2)
        
        #enforcement of terminal velocity, using a simplified model here, assuming v_term = 15.0 
        if self.vel[0] > 3.0:
            self.vel[0] = 3.0
        elif self.vel[0] < -3.0:
            self.vel[0] = -3.0

        if self.vel[1] > 3.0:
            self.vel[1] = 3.0
        elif self.vel[1] < -3.0:
            self.vel[1] = -3.0

        #enforcement of terminal angular velocity, also a simplified model
        if self.omega[0] > 10.0:
            self.omega[0] = 10.0
        elif self.omega[0] < -10.0:
            self.omega[0] = -10.0
            

        
        