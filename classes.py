import math

class PID:
    def__init__(self, P, I, D):
        self.P = P
        self.I = I
        self.D = D
        self.cum_err = 0.0
        self.last_err = 0.0
    def fwd(sv, pv, dt):
        err = sv - pv
        output = P*err + I*cum_err*dt + D*(err-last_err)*dt
        self.last_err = err
        self.cum_err += err
        return output
        
class Drone_2D:
    def __init__(self, m, I, b, h, k):
        self.m = m
        self.I = I
        self.b = b
        self.h = h
        self. k = k
        
        self.pos = [0.0, 0.0]       #position of CoG (x, y)
        self.vel = [0.0, 0.0]       #velocity vector (x, y)
        self.rot = [0.0]            #angular velocity
        self.omega = [0.0]          #angle to parallel
    
    #motor output is a list of motor speeds in rpm
    def update(motor_output, dt):
        #forces and torques generated by motor ouputs:
        mo1 = motor_output[0]
        mo2 = motor_output[1]
        F1 = k*(mo1**2)
        F2 = k*(mo2**2)
        T = (b/2)*(F1 - F2)
        #resultant accelerations
        Fx = F1*math.cos(math.radians(90+self.rot[0])) + F2*math.cos(math.radians(90+self.rot[0]))
        Fy = -m*9.81 + F1*math.sin(math.radians(90+self.rot[0])) + F2*math.sin(math.radians(90+self.rot[0]))
        Ax = Fx/m
        Ay = Fy/m
        Alpha = T/I
        #velocity updates
        self.vel[0] += Ax*dt
        self.vel[1] += Ay*dt
        self.omega[0] += Alpha*dt
        #position updates
        self.pos[0] += self.vel[0]*dt + 0.5*Ax*(dt**2)
        self.pos[1] += self.vel[1]*dt + 0.5*Ay*(dt**2)
        self.rot[0] += self.omega[0]*dt + 0.5*Alpha*(dt**2)